import argparse
import logging
from collections import Counter
from pathlib import Path
from typing import List, Tuple

import geopandas as gpd
import pandas as pd

from coclico.config import csv_separator
from coclico.io import read_config_file
from coclico.mobj0.mobj0 import MOBJ0


def check_paired_objects(c1_file: Path, ref_file: Path, classes: List) -> Tuple[Counter, Counter]:
    """Pair objects from 2 geodataframes (ie. 2 lists of geometries)
    Pairing is made based on geometries intersections:
    - paired objects are objects from ref that have an intersection with at least one object from c1
    - not paired objects are both:
        - objects from ref that have no intersection with any object in c1
        - objects from c1 that have no intersection with any object in ref

    Args:
        c1_file (Path): Path to the geojson file with geometries from c1
        ref_geometries (Path):  Path to the geojson file with geometries from the reference
        classes (List): ordered list of clsses (to match "layer" values with classes in the output)

    Returns:
        Tuple[Counter, Counter, Counter]: (ref_object_count, paired_count, not_paired_count) Numbers of:
        - geometries in ref
        - paired geometries
        - not paired geometries

    """
    ref_object_count = Counter()
    paired_count = Counter()
    not_paired_count = Counter()

    c1_geometries = gpd.read_file(c1_file)
    if not len(c1_geometries.index):
        c1_geometries = gpd.GeoDataFrame(columns=["layer", "geometry"])

    ref_geometries = gpd.read_file(ref_file)
    if not len(ref_geometries.index):
        ref_geometries = gpd.GeoDataFrame(columns=["layer", "geometry"])

    for ii, class_key in enumerate(classes):
        c1_geom_layer = c1_geometries[c1_geometries.layer == ii]
        nb_c1 = len(c1_geom_layer.index)
        ref_geom_layer = ref_geometries[ref_geometries.layer == ii]
        nb_ref = len(ref_geom_layer.index)
        logging.debug(f"For class {class_key}, found {nb_c1} in c1 and {nb_ref} in ref ")
        # Count objects in reference
        ref_object_count[class_key] = nb_ref

        # Find all geometries in ref that have an intersection with a geometry in c1
        # and store then as paired objects
        ref_intersection_gdf = ref_geom_layer.sjoin(c1_geom_layer, how="inner", lsuffix="ref", rsuffix="c1")
        # Count unique indices in ref_intersection_gdf to count each ref geometry only once
        # even if it is paired with several c1 geometries
        nb_ref_intersection = len(ref_intersection_gdf[~ref_intersection_gdf.index.duplicated(keep="first")])
        paired_count[class_key] = nb_ref_intersection

        # Find non paired objects as:
        # Objects from ref that have no intersection with any object in c1
        # + objects from c1 that have no intersection with any object in ref
        c1_intersection_gdf = c1_geom_layer.sjoin(ref_geom_layer, how="inner", lsuffix="c1", rsuffix="ref")
        # Count unique indices in c1_intersection_gdf to count each c1 geometry only once
        # even if it is paired with several ref geometries
        nb_c1_intersection = len(c1_intersection_gdf[~c1_intersection_gdf.index.duplicated(keep="first")])
        not_paired_count[class_key] = nb_c1 - nb_c1_intersection + nb_ref - nb_ref_intersection

    return ref_object_count, paired_count, not_paired_count


def compute_metric_relative(c1_dir: Path, ref_dir: Path, config_file: str, output_csv: Path, output_csv_tile: Path):
    """Generate relative metrics for mobj0 from the number of paired objects between the reference and c1
    (classification to compare) using the polygons generated by the mobj0 intrinsic metric.
    Paired objects are objects that are found both in c1 and the reference, "not paired" objects are
    objects that are found either only in the reference or only in c1.
    The pairing method is implemented and explained in the check_paired_objects method.

    The computed metrics are:
    - ref_object_count: The number of objects in ref
    - paired_count: The number of paired objects (found both in c1 and ref)
    - not_paired_count: The number of "not paired" objects (found only in c1 or only in ref)

    These metrics are stored tile by tile and class by class in the output_csv_tile file
    These metrics are stored class by class for the whole data in the output_csv file


    Args:
        c1_dir (Path):  path to the c1 classification directory,
                        where there are json files with the result of mobj0 intrinsic metric
        ref_dir (Path): path to the reference classification directory,
                        where there are json files with the result of mobj0 intrinsic metric
        config_file (Path):  Coclico configuration file
        output_csv (Path):  path to output csv file
        output_csv_tile (Path):  path to output csv file, result by tile
    """
    config_dict = read_config_file(config_file)
    class_weights = config_dict[MOBJ0.metric_name]["weights"]
    classes = sorted(class_weights.keys())
    output_csv.parent.mkdir(parents=True, exist_ok=True)
    output_csv_tile.parent.mkdir(parents=True, exist_ok=True)

    total_ref_object_count = Counter()
    total_paired_count = Counter()
    total_not_paired_count = Counter()

    data = []

    for ref_file in ref_dir.iterdir():
        c1_file = c1_dir / ref_file.name
        ref_object_count, paired_count, not_paired_count = check_paired_objects(c1_file, ref_file, classes)

        total_ref_object_count += Counter(ref_object_count)
        total_paired_count += Counter(paired_count)
        total_not_paired_count += Counter(not_paired_count)

        new_line = [
            {
                "tile": ref_file.stem,
                "class": cl,
                "ref_object_count": ref_object_count.get(cl, 0),
                "paired_count": paired_count.get(cl, 0),
                "not_paired_count": not_paired_count.get(cl, 0),
            }
            for cl in classes
        ]
        data.extend(new_line)

    output_csv.parent.mkdir(parents=True, exist_ok=True)
    df = pd.DataFrame(data)
    df.to_csv(output_csv_tile, index=False, sep=csv_separator)
    logging.debug(df.to_markdown())

    data = [
        {
            "class": cl,
            "ref_object_count": total_ref_object_count.get(cl, 0),
            "paired_count": total_paired_count.get(cl, 0),
            "not_paired_count": total_not_paired_count.get(cl, 0),
        }
        for cl in classes
    ]
    df = pd.DataFrame(data)
    df.to_csv(output_csv, index=False, sep=csv_separator)

    logging.debug(df.to_markdown())

    logging.debug(df.to_markdown())


def parse_args():
    parser = argparse.ArgumentParser("Run mobj0 metric on one tile")
    parser.add_argument(
        "-i",
        "--input-dir",
        required=True,
        type=Path,
        help="Path to the classification directory, \
        where there are geojson files with the result of mobj0 intrinsic metric",
    )
    parser.add_argument(
        "-r",
        "--ref-dir",
        required=True,
        type=Path,
        help="Path to the reference directory, where there are geojson files with the result of mobj0 intrinsic "
        + "metric",
    )
    parser.add_argument("-o", "--output-csv", required=True, type=Path, help="Path to the CSV output file")
    parser.add_argument(
        "-t", "--output-csv-tile", required=True, type=Path, help="Path to the CSV output file, result by tile"
    )
    parser.add_argument(
        "-c",
        "--config-file",
        required=True,
        type=Path,
        help="Coclico configuration file",
    )

    return parser.parse_args()


if __name__ == "__main__":
    args = parse_args()
    logging.basicConfig(format="%(message)s", level=logging.DEBUG)
    compute_metric_relative(
        c1_dir=Path(args.input_dir),
        ref_dir=Path(args.ref_dir),
        config_file=args.config_file,
        output_csv=Path(args.output_csv),
        output_csv_tile=Path(args.output_csv_tile),
    )
